<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Live WhatsApp messaging interface for Amapola Resort agents.">
    <title>Live Messages - Amapola Resort</title>
    <link rel="icon" type="image/png" href="/static/favicon.png">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            height: 100vh;
            display: flex;
            background-color: #f0f2f5;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100%;
        }
        .sidebar {
            width: 30%;
            min-width: 300px;
            background-color: #f0f2f5;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            background-color: #075E54;
            color: white;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .sidebar-header .profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ddd;
            margin-right: 10px;
        }
        .sidebar-header .title {
            flex-grow: 1;
            font-size: 16px;
            font-weight: 500;
        }
        .sidebar-header .icons {
            display: flex;
            gap: 20px;
        }
        .sidebar-header .icons span {
            font-size: 20px;
            cursor: pointer;
        }
        .ai-toggle-container {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }
        .ai-toggle-container label {
            font-size: 12px;
            margin-right: 5px;
        }
        .ai-toggle-container input[type="checkbox"] {
            appearance: none;
            width: 34px;
            height: 20px;
            background-color: #ccc;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            outline: none;
        }
        .ai-toggle-container input[type="checkbox"]:checked {
            background-color: #34C759;
        }
        .ai-toggle-container input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }
        .ai-toggle-container input[type="checkbox"]:checked::before {
            transform: translateX(14px);
        }
        .conversation-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            background-color: #fff;
        }
        .conversation-item:hover {
            background-color: #f0f0f0;
        }
        .conversation-item.active {
            background-color: #e0f7fa;
        }
        .profile-pic {
            width: 40px;
            height: 40px;
            background-color: #ccc;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .conversation-info {
            flex: 1;
            min-width: 0;
        }
        .conversation-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .username {
            font-weight: bold;
            color: #333;
        }
        .timestamp {
            color: #888;
            font-size: 0.8em;
        }
        .message-preview {
            color: #555;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .chat-header {
            background-color: #075E54;
            color: white;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .chat-header .profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #ddd;
            margin-right: 10px;
        }
        .chat-header .contact-info {
            flex-grow: 1;
        }
        .chat-header .contact-info h1 {
            font-size: 16px;
            margin: 0;
            font-weight: 500;
        }
        .chat-header .contact-info p {
            font-size: 12px;
            margin: 0;
            opacity: 0.7;
        }
        .chat-header .icons {
            display: flex;
            gap: 20px;
        }
        .chat-header .icons span {
            font-size: 20px;
            cursor: pointer;
        }
        .chat-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px 10px;
            background: #e5ddd5;
            background-size: auto;
        }
        .message {
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            max-width: 70%;
        }
        .user-message {
            align-self: flex-start;
            margin-right: auto;
        }
        .agent-message {
            align-self: flex-end;
            margin-left: auto;
        }
        .ai-message {
            align-self: flex-end;
            margin-left: auto;
        }
        .message-bubble {
            padding: 8px 12px;
            border-radius: 7.5px;
            position: relative;
            word-wrap: break-word;
            font-size: 14.2px;
            line-height: 1.4;
        }
        .user-message .message-bubble {
            background-color: #FFFFFF;
            border-bottom-left-radius: 2px;
            box-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.13);
        }
        .user-message .message-bubble::after {
            content: '';
            position: absolute;
            left: -5px;
            bottom: 0;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle at bottom right, transparent 50%, #FFFFFF 50%);
        }
        .agent-message .message-bubble {
            background-color: #DCF8C6;
            border-bottom-right-radius: 2px;
        }
        .agent-message .message-bubble::after {
            content: '';
            position: absolute;
            right: -5px;
            bottom: 0;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle at bottom left, transparent 50%, #DCF8C6 50%);
        }
        .ai-message .message-bubble {
            background-color: #DCF8C6;
            border-bottom-right-radius: 2px;
        }
        .ai-message .message-bubble::after {
            content: '';
            position: absolute;
            right: -5px;
            bottom: 0;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle at bottom left, transparent 50%, #DCF8C6 50%);
        }
        .message-meta {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            align-self: flex-end;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .message-meta .checkmark {
            font-size: 12px;
            color: #34B7F1;
        }
        .date-separator {
            text-align: center;
            margin: 20px 0;
            font-size: 12px;
            color: #666;
            position: relative;
        }
        .date-separator::before,
        .date-separator::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background-color: #ddd;
        }
        .date-separator::before {
            left: 0;
        }
        .date-separator::after {
            right: 0;
        }
        .typing-indicator {
            display: none;
            align-self: flex-start;
            margin-bottom: 10px;
        }
        .typing-indicator .dots {
            display: flex;
            gap: 5px;
            padding: 8px 12px;
            background-color: #DCF8C6;
            border-radius: 7.5px;
        }
        .typing-indicator .dot {
            width: 8px;
            height: 8px;
            background-color: #999;
            border-radius: 50%;
            animation: bounce 1.2s infinite;
        }
        .typing-indicator .dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-indicator .dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-5px);
            }
            60% {
                transform: translateY(-2px);
            }
        }
        .input-container {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #F0F2F5;
            border-top: 1px solid #ddd;
        }
        #message-input {
            flex-grow: 1;
            padding: 10px 40px 10px 15px;
            border: none;
            border-radius: 20px;
            background-color: #FFFFFF;
            margin: 0 10px;
            outline: none;
            font-size: 14px;
        }
        .input-container .icon {
            font-size: 20px;
            color: #54656F;
            cursor: pointer;
        }
        #send-button {
            background-color: #00AF9C;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        #send-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #send-button:hover:not(:disabled) {
            background-color: #009688;
        }
        #send-button::before {
            content: "➤";
            font-size: 18px;
            transform: rotate(-45deg);
        }
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toast {
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            max-width: 300px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast.error {
            background-color: #E74C3C;
        }
        .toast.success {
            background-color: #34C759;
        }
        .toast.info {
            background-color: #54656F;
        }
        /* Adjust dropdown menu styling to match the theme */
        .dropdown-menu {
            background-color: #075E54;
            border: none;
        }
        .dropdown-item {
            color: white;
            font-size: 14px;
        }
        .dropdown-item:hover {
            background-color: #064c44;
        }
    </style>
</head>
<body>
    <div class="container" id="dashboard">
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="profile-pic"></div>
                <div class="title">Amapola Resort (WhatsApp)</div>
                <div class="ai-toggle-container">
                    <label for="ai-toggle">AI</label>
                    <input type="checkbox" id="ai-toggle" checked aria-label="Toggle AI">
                </div>
                <div class="icons">
                    <!-- Replaced 3 dots with dropdown menu -->
                    <div class="dropdown">
                        <span class="dropdown-toggle" id="dropdownMenuButton" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Menu">
                            ⋮
                        </span>
                        <ul class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                            <li><a class="dropdown-item" href="#" id="logoutButton">Logout</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="conversation-list" id="conversation-list">
                <!-- Conversations will be appended here -->
            </div>
        </div>
        <div class="chat-area">
            <div class="chat-header" id="chat-header" style="display: none;">
                <div class="profile-pic"></div>
                <div class="contact-info">
                    <h1 id="chat-title">Select a conversation</h1>
                    <p>End-to-end encrypted</p>
                </div>
                <div class="icons">
                    <span aria-label="Chat options">⋮</span>
                </div>
            </div>
            <div class="chat-container" id="chat-box" aria-live="polite">
                <!-- Messages will be appended here -->
            </div>
            <div class="input-container" id="input-container" style="display: none;">
                <span class="icon" id="emoji-icon" aria-label="Open emoji picker" role="button" tabindex="0">😊</span>
                <span class="icon" id="attach-icon" aria-label="Attach file" role="button" tabindex="0">📎</span>
                <input type="text" id="message-input" placeholder="Message" aria-label="Type a message">
                <button id="send-button" aria-label="Send message" disabled></button>
            </div>
        </div>
    </div>
    <div class="toast-container" id="toast-container"></div>

    <!-- Bootstrap JS and Popper.js (required for dropdown) -->
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://unpkg.com/emoji-picker-element@1.12.0/dist/index.js" type="module"></script>
    <script>
        // Explicitly specify the Socket.IO server URL with improved connection settings
        const socket = io('https://hotel-chatbot-1qj5.onrender.com', {
            path: "/socket.io",
            transports: ["websocket", "polling"],
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            randomizationFactor: 0.5,
            withCredentials: true
        });

        let currentConversationId = null;
        let currentChatId = null;
        let currentAgent = null;
        let lastMessageDate = null;
        let isConnected = false;
        let sentMessages = new Set();
        let lastFetchedConversations = null; // Cache for conversation list
        let lastFetchedMessages = {}; // Cache for messages per conversation
        let lastMessageTimestamp = null; // Track the timestamp of the last message

        // Debug Socket.IO connection status
        socket.on("connect", () => {
            isConnected = true;
            console.log("Socket.IO connected successfully with ID:", socket.id);
            showToast("Connected to server", "success");
            // Rejoin the current conversation if it exists
            if (currentConversationId) {
                console.log("Rejoining conversation on connect:", currentConversationId);
                socket.emit("join_conversation", { conversation_id: currentConversationId }, (response) => {
                    console.log("Join conversation response on connect:", response);
                });
            }
            // Log connection status periodically
            setInterval(() => {
                console.log("Socket connection status:", socket.connected, "Current conversation ID:", currentConversationId);
                if (isConnected) {
                    socket.emit("ping", { timestamp: new Date().toISOString() });
                }
            }, 5000); // Log every 5 seconds
        });

        socket.on("connect_error", (error) => {
            console.error("Socket.IO connection error:", error);
            showToast("Failed to connect to server: " + error.message, "error");
        });

        socket.on("disconnect", (reason) => {
            isConnected = false;
            console.warn("Socket.IO disconnected. Reason:", reason);
            showToast("Disconnected from server: " + reason, "error");
            // Start polling as a fallback
            startPollingForMessages();
        });

        function showToast(message, type = "info") {
            const toastContainer = document.getElementById("toast-container");
            const toast = document.createElement("div");
            toast.className = `toast ${type}`;
            toast.setAttribute("role", "alert");
            toast.setAttribute("aria-live", "assertive");
            toast.textContent = message;
            toastContainer.appendChild(toast);

            setTimeout(() => toast.classList.add("show"), 100);
            setTimeout(() => {
                toast.classList.remove("show");
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function addDateSeparator(dateStr) {
            const chatBox = document.getElementById("chat-box");
            const separator = document.createElement("div");
            separator.className = "date-separator";
            separator.textContent = dateStr;
            chatBox.appendChild(separator);
        }

        function appendMessage(msg, sender) {
            console.log("Appending message:", msg, "Sender:", sender);
            const chatBox = document.getElementById("chat-box");
            let messageDate = new Date(msg.timestamp);
            if (isNaN(messageDate.getTime())) {
                messageDate = new Date(msg.timestamp + "Z");
            }
            if (isNaN(messageDate.getTime())) {
                console.error("Invalid message timestamp:", msg.timestamp);
                return;
            }
            const dateStr = formatDateForSeparator(msg.timestamp);

            if (!lastMessageDate || formatDateForSeparator(lastMessageDate) !== dateStr) {
                console.log("Adding date separator:", dateStr);
                addDateSeparator(dateStr);
                lastMessageDate = messageDate;
            }

            const div = document.createElement("div");
            const isUser = sender === "user";
            const isAgent = sender === "agent";
            div.className = "message";
            div.classList.add(isUser ? "user-message" : isAgent ? "agent-message" : "ai-message");

            const bubble = document.createElement("div");
            bubble.className = "message-bubble";
            bubble.textContent = msg.message;
            div.appendChild(bubble);

            const meta = document.createElement("div");
            meta.className = "message-meta";
            const time = formatTimestamp(msg.timestamp);
            meta.innerHTML = `${time}${isAgent ? '<span class="checkmark">✓✓</span>' : ""}`;
            div.appendChild(meta);

            chatBox.appendChild(div);
            console.log("Message appended to chatBox:", div);
            chatBox.scrollTop = chatBox.scrollHeight;

            // Update the last message timestamp
            if (!lastMessageTimestamp || new Date(msg.timestamp) > new Date(lastMessageTimestamp)) {
                lastMessageTimestamp = msg.timestamp;
            }
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function formatDateForSeparator(timestamp) {
            let date = new Date(timestamp);
            if (isNaN(date.getTime())) {
                date = new Date(timestamp + "Z");
            }
            if (isNaN(date.getTime())) {
                console.error("Invalid timestamp for date separator:", timestamp);
                return "Unknown Date";
            }
            const today = new Date();
            if (date.toDateString() === today.toDateString()) return "Today";
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            if (date.toDateString() === yesterday.toDateString()) return "Yesterday";
            return date.toLocaleDateString([], { month: "short", day: "numeric", year: "numeric" });
        }

        async function loadMessagesForConversation(convoId, sinceTimestamp = null) {
            const chatBox = document.getElementById("chat-box");
            const chatHeader = document.getElementById("chat-header");
            const chatTitle = document.getElementById("chat-title");
            try {
                console.log("Fetching messages for convoId:", convoId, "sinceTimestamp:", sinceTimestamp);
                // If sinceTimestamp is provided, fetch only new messages
                let url = `/messages/${convoId}`;
                if (sinceTimestamp) {
                    url += `?since=${encodeURIComponent(sinceTimestamp)}`;
                }

                // Check if messages are cached and no sinceTimestamp is provided
                if (!sinceTimestamp && lastFetchedMessages[convoId]) {
                    console.log("Using cached messages for convoId:", convoId);
                    const data = lastFetchedMessages[convoId];
                    chatBox.innerHTML = "";
                    lastMessageDate = null;
                    chatHeader.style.display = "flex";
                    chatTitle.textContent = data.username || "Unknown User";

                    if (data.messages && data.messages.length > 0) {
                        data.messages.forEach(msg => {
                            appendMessage(msg, msg.sender);
                        });
                    } else {
                        chatBox.innerHTML = "<p>No messages found for this conversation.</p>";
                    }
                    return;
                }

                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    if (response.status === 503 || response.status === 429) {
                        showToast("Server is under heavy load, please try again later", "error");
                    }
                    throw new Error(`HTTP error! Status: ${response.status}, Response: ${errorText}`);
                }
                const data = await response.json();
                console.log("Messages fetched:", data);

                if (!sinceTimestamp) {
                    // Cache the messages only for full fetches
                    lastFetchedMessages[convoId] = data;
                    chatBox.innerHTML = "";
                    lastMessageDate = null;
                    chatHeader.style.display = "flex";
                    chatTitle.textContent = data.username || "Unknown User";
                }

                if (data.messages && data.messages.length > 0) {
                    data.messages.forEach(msg => {
                        appendMessage(msg, msg.sender);
                    });
                } else if (!sinceTimestamp) {
                    chatBox.innerHTML = "<p>No messages found for this conversation.</p>";
                }
            } catch (error) {
                console.error("Error loading messages:", error);
                if (!sinceTimestamp) {
                    chatBox.innerHTML = "<p>Failed to load messages. Please try again later.</p>";
                }
                showToast("Failed to load messages: " + error.message, "error");
            }
        }

        async function fetchConversations() {
            const conversationList = document.getElementById("conversation-list");
            try {
                const response = await fetch("/all-whatsapp-messages");
                if (!response.ok) {
                    const errorText = await response.text();
                    if (response.status === 503 || response.status === 429) {
                        showToast("Server is under heavy load, please try again later", "error");
                    }
                    throw new Error(`HTTP error! Status: ${response.status}, Response: ${errorText}`);
                }
                const data = await response.json();
                lastFetchedConversations = data.conversations; // Cache the conversations
                conversationList.innerHTML = "";
                if (data.conversations && data.conversations.length > 0) {
                    data.conversations.forEach(convo => {
                        const convoElement = document.createElement("div");
                        convoElement.className = "conversation-item";
                        convoElement.dataset.convoId = convo.convo_id;
                        convoElement.dataset.chatId = convo.chat_id;
                        convoElement.innerHTML = `
                            <div class="profile-pic"></div>
                            <div class="conversation-info">
                                <div class="conversation-header">
                                    <span class="username">${convo.username}</span>
                                    <span class="timestamp">${formatDateForSeparator(convo.last_updated)}</span>
                                </div>
                                <div class="message-preview">Last updated: ${new Date(convo.last_updated).toLocaleTimeString()}</div>
                            </div>
                        `;
                        convoElement.addEventListener("click", () => {
                            console.log("Selecting conversation:", convo.convo_id, convo.chat_id);
                            selectConversation(convo.convo_id, convo.chat_id);
                        });
                        conversationList.appendChild(convoElement);
                    });
                    // Auto-select the first conversation if none is selected
                    if (!currentConversationId && data.conversations.length > 0) {
                        selectConversation(data.conversations[0].convo_id, data.conversations[0].chat_id);
                    }
                } else {
                    conversationList.innerHTML = "<p>No WhatsApp conversations found.</p>";
                }
            } catch (error) {
                console.error("Error fetching conversations:", error);
                conversationList.innerHTML = "<p>Failed to load conversations. Please try again later.</p>";
                showToast("Failed to load conversations: " + error.message, "error");
            }
        }

        async function fetchSettings() {
            try {
                const response = await fetch("/settings");
                if (!response.ok) {
                    if (response.status === 503 || response.status === 429) {
                        showToast("Server is under heavy load, please try again later", "error");
                    }
                    throw new Error(`Failed to fetch settings: ${response.status}`);
                }
                const settings = await response.json();
                const aiToggle = document.getElementById("ai-toggle");
                aiToggle.checked = settings.ai_enabled === "1";
            } catch (error) {
                console.error("Error fetching settings:", error);
                showToast("Error fetching settings, defaulting AI to enabled", "error");
                const aiToggle = document.getElementById("ai-toggle");
                aiToggle.checked = true;
            }
        }

        function selectConversation(convoId, chatId) {
            // Ensure convoId is a string
            convoId = String(convoId);
            console.log("selectConversation called with convoId:", convoId, "chatId:", chatId);

            if (currentConversationId) {
                console.log("Leaving previous conversation room:", currentConversationId);
                socket.emit("leave_conversation", { conversation_id: currentConversationId }, () => {
                    console.log(`Left conversation ${currentConversationId}`);
                });
            }
            currentConversationId = convoId;
            currentChatId = chatId;

            // Ensure the client is connected before emitting join_conversation
            if (socket.connected) {
                console.log("Emitting join_conversation for convoId:", convoId);
                socket.emit("join_conversation", { conversation_id: convoId }, (response) => {
                    console.log("Join conversation response:", response);
                });
            } else {
                console.warn("Socket not connected, waiting for connection to join conversation:", convoId);
                socket.on("connect", () => {
                    console.log("Socket connected, now joining conversation:", convoId);
                    socket.emit("join_conversation", { conversation_id: convoId }, (response) => {
                        console.log("Join conversation response after reconnect:", response);
                    });
                });
            }

            const conversationList = document.getElementById("conversation-list");
            const items = conversationList.getElementsByClassName("conversation-item");
            for (let item of items) {
                item.classList.remove("active");
                if (item.dataset.convoId === convoId) {
                    item.classList.add("active");
                }
            }

            lastMessageTimestamp = null; // Reset the last message timestamp
            loadMessagesForConversation(convoId);

            const inputContainer = document.getElementById("input-container");
            inputContainer.style.display = "flex";
            const messageInput = document.getElementById("message-input");
            const sendButton = document.getElementById("send-button");
            sendButton.disabled = !messageInput.value.trim();

            // Start polling for new messages as a fallback
            startPollingForMessages();
        }

        function sendMessage() {
            if (!currentConversationId) {
                showToast("Please select a conversation to reply to", "error");
                return;
            }

            const messageInput = document.getElementById("message-input");
            const sendButton = document.getElementById("send-button");
            const message = messageInput.value.trim();
            if (!message) {
                showToast("Please enter a message to send", "error");
                return;
            }

            const timestamp = new Date().toISOString();
            const messageKey = `agent:${message}:${timestamp}`;
            sentMessages.add(messageKey);
            console.log("Added to sentMessages:", messageKey);

            socket.emit("agent_message", {
                convo_id: currentConversationId,
                message: message,
                channel: "whatsapp",
            });

            messageInput.value = "";
            sendButton.disabled = true;
        }

        // Function to dynamically update the conversation list
        function updateConversationList(data) {
            console.log("Updating conversation list with data:", data);
            const conversationList = document.getElementById("conversation-list");
            let convoItem = Array.from(conversationList.children).find(item =>
                item.dataset.chatId === data.chat_id
            );

            // Create or update the conversation item
            const isActive = convoItem && convoItem.classList.contains("active");
            if (!convoItem) {
                // Create a new conversation item if it doesn't exist
                convoItem = document.createElement("div");
                convoItem.className = "conversation-item";
                convoItem.dataset.convoId = data.convo_id;
                convoItem.dataset.chatId = data.chat_id;
            }

            // Update the conversation item
            convoItem.innerHTML = `
                <div class="profile-pic"></div>
                <div class="conversation-info">
                    <div class="conversation-header">
                        <span class="username">${data.username || "Unknown User"}</span>
                        <span class="timestamp">${formatDateForSeparator(data.timestamp)}</span>
                    </div>
                    <div class="message-preview">${data.message}</div>
                </div>
            `;
            if (isActive) {
                convoItem.classList.add("active");
            }

            // Move the conversation to the top of the list
            conversationList.prepend(convoItem);

            // Reattach the click event listener
            convoItem.addEventListener("click", () => {
                console.log("Selecting conversation from updated list:", data.convo_id, data.chat_id);
                selectConversation(data.convo_id, data.chat_id);
            });

            // Update the cached conversations
            if (lastFetchedConversations) {
                const convoIndex = lastFetchedConversations.findIndex(c => c.chat_id === data.chat_id);
                if (convoIndex !== -1) {
                    lastFetchedConversations[convoIndex].last_updated = data.timestamp;
                    lastFetchedConversations[convoIndex].message_preview = data.message;
                } else {
                    lastFetchedConversations.unshift({
                        convo_id: data.convo_id,
                        chat_id: data.chat_id,
                        username: data.username,
                        last_updated: data.timestamp,
                        message_preview: data.message
                    });
                }
            }
        }

        // Fallback polling mechanism for new messages
        let pollingInterval = null;
        function startPollingForMessages() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            pollingInterval = setInterval(() => {
                if (currentConversationId && lastMessageTimestamp) {
                    console.log("Polling for new messages since:", lastMessageTimestamp);
                    loadMessagesForConversation(currentConversationId, lastMessageTimestamp);
                }
            }, 30000); // Poll every 30 seconds
        }

        function stopPollingForMessages() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            const dashboardSection = document.getElementById("dashboard");
            if (!dashboardSection) {
                console.error("Required DOM element (dashboard) is missing.");
                return;
            }

            const chatBox = document.getElementById("chat-box");
            chatBox.innerHTML = "<p>Select a conversation to view messages.</p>";

            fetchConversations();
            fetchSettings();

            const messageInput = document.getElementById("message-input");
            const sendButton = document.getElementById("send-button");
            if (messageInput && sendButton) {
                messageInput.addEventListener("keypress", (e) => {
                    if (e.key === "Enter" || e.keyCode === 13) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
                messageInput.addEventListener("input", () => {
                    sendButton.disabled = !messageInput.value.trim() || !currentConversationId;
                });
                sendButton.addEventListener("click", sendMessage);
            }

            const emojiIcon = document.getElementById("emoji-icon");
            if (emojiIcon) {
                const picker = document.createElement("emoji-picker");
                picker.style.position = "absolute";
                picker.style.bottom = "60px";
                picker.style.left = "20px";
                picker.style.display = "none";
                document.body.appendChild(picker);

                emojiIcon.addEventListener("click", () => {
                    picker.style.display = picker.style.display === "none" ? "block" : "none";
                });

                picker.addEventListener("emoji-click", (event) => {
                    messageInput.value += event.detail.unicode;
                    messageInput.focus();
                    sendButton.disabled = !messageInput.value.trim() || !currentConversationId;
                    picker.style.display = "none";
                });
            }

            const attachIcon = document.getElementById("attach-icon");
            if (attachIcon) {
                attachIcon.addEventListener("click", () => {
                    showToast("File attachment is not yet implemented", "info");
                });
            }

            // Handle logout button click
            const logoutButton = document.getElementById("logoutButton");
            if (logoutButton) {
                logoutButton.addEventListener("click", (e) => {
                    e.preventDefault();
                    fetch("/logout", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                    })
                        .then((response) => response.json())
                        .then((data) => {
                            if (data.message === "Logged out successfully") {
                                window.location.href = "/login";
                            } else {
                                showToast(data.message || "Logout failed", "error");
                            }
                        })
                        .catch((error) => {
                            console.error("Error during logout:", error);
                            showToast("An error occurred during logout", "error");
                        });
                });
            }
        });

        document.getElementById("ai-toggle").addEventListener("change", async (e) => {
            const aiEnabled = e.target.checked ? "1" : "0";
            try {
                const response = await fetch("/settings", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ key: "ai_enabled", value: aiEnabled }),
                });
                if (!response.ok) {
                    if (response.status === 503 || response.status === 429) {
                        showToast("Server is under heavy load, please try again later", "error");
                    }
                    throw new Error(`Failed to update AI settings: ${response.status}`);
                }
                const data = await response.json();
                if (data.status !== "success") throw new Error(data.error || "Unknown error");
                showToast(`AI has been ${aiEnabled === "1" ? "enabled" : "disabled"}`, "success");
            } catch (error) {
                console.error("Error updating AI settings:", error);
                e.target.checked = !e.target.checked;
                showToast(`Error updating AI settings: ${error.message}`, "error");
            }
        });

        socket.on("status", (data) => {
            console.log("Received status event:", data);
            showToast(data.message, "info");
        });

        socket.on("error", (data) => {
            console.error("Received error event:", data);
            showToast("Error: " + data.message, "error");
        });

        socket.on("new_message", (data) => {
            console.log("Received new_message:", data);
            console.log("Current conversation ID:", currentConversationId);
            console.log("Socket connected status:", socket.connected);

            const messageKey = `${data.sender}:${data.message}:${data.timestamp}`;
            console.log("Checking messageKey in sentMessages:", messageKey, sentMessages.has(messageKey));

            if (data.sender === "agent" && sentMessages.has(messageKey)) {
                console.log("Skipping duplicate agent message:", messageKey);
                sentMessages.delete(messageKey);
                return;
            }

            if (String(data.convo_id) === String(currentConversationId)) {
                console.log("Appending message for convo_id:", data.convo_id);
                appendMessage({ message: data.message, timestamp: data.timestamp }, data.sender);
                // Update the cached messages
                if (lastFetchedMessages[currentConversationId]) {
                    lastFetchedMessages[currentConversationId].messages.push({
                        message: data.message,
                        sender: data.sender,
                        timestamp: data.timestamp
                    });
                    lastMessageTimestamp = data.timestamp;
                }
                // Stop polling since we received a real-time update
                stopPollingForMessages();
            } else {
                console.log(`Message not appended: convo_id ${data.convo_id} does not match currentConversationId ${currentConversationId}`);
            }
        });

        socket.on("live_message", (data) => {
            console.log("Received live_message:", data);
            console.log("Socket connected status:", socket.connected);

            const messageKey = `${data.sender}:${data.message}:${data.timestamp}`;
            console.log("Checking messageKey in sentMessages:", messageKey, sentMessages.has(messageKey));

            if (data.sender === "agent" && sentMessages.has(messageKey)) {
                console.log("Skipping duplicate agent message:", messageKey);
                sentMessages.delete(messageKey);
                return;
            }

            // Update the conversation list dynamically
            updateConversationList(data);
        });

        socket.on("settings_updated", (settings) => {
            if ("ai_enabled" in settings) {
                const aiToggle = document.getElementById("ai-toggle");
                aiToggle.checked = settings.ai_enabled === "1";
                showToast(`AI has been ${settings.ai_enabled === "1" ? "enabled" : "disabled"}`, "success");
            }
        });

        socket.on("reconnect", (attempt) => {
            console.log("Socket.IO reconnected after", attempt, "attempts");
            fetchConversations();
            fetchSettings();
            if (currentConversationId) {
                loadMessagesForConversation(currentConversationId);
                socket.emit("join_conversation", { conversation_id: currentConversationId }, (response) => {
                    console.log("Join conversation response after reconnect:", response);
                });
            }
            showToast("Reconnected to server", "success");
            // Stop polling since we reconnected
            stopPollingForMessages();
        });

        socket.on("reconnect_error", (error) => {
            console.error("Socket.IO reconnect error:", error);
            showToast("Failed to reconnect to server", "error");
            // Start polling as a fallback
            startPollingForMessages();
        });

        socket.on("pong", (data) => {
            console.log("Received pong:", data);
        });
    </script>
</body>
</html>
